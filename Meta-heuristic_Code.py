# -*- coding: utf-8 -*-
"""bsa (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Z4vQJ0Z7m0xwgXU_TRmGVFHp-ZdSdrVS
"""

import numpy as np
import time

def ackley(x):
    a = 20.0
    b = 0.2
    c = 2 * np.pi
    d = len(x)
    return -a * np.exp(-b * np.sqrt(np.sum(x**2) / d)) - np.exp(np.sum(np.cos(c * x))/d) + a + np.exp(1)

def rastrigin(x):
    d = len(x)
    return 10 * d + np.sum(x**2 - 10 * np.cos(2 * np.pi * x))

def schwefel(x):
    d = len(x)
    return 418.9829 * d - np.sum(x * np.sin(np.sqrt(np.abs(x))))

def rosenbrock(x):
    return np.sum(100 * (x[1:] - x[:-1]**2)**2 + (1 - x[:-1])**2)

dimensions = 30
optimal_value = 10e-16
max_eval = 20000
num_runs = 30
pop_size = 30
mixrate = 1

bounds_ackley = (-32.768,32.768)
bounds_rastrigin = (-5.12,5.12)
bounds_schwefel = (-500,500)
bounds_rosenbrock = (-5,10)

def init_population(num_individuals, dimensions, bounds):
    return np.random.uniform(bounds[0], bounds[1], (num_individuals, dimensions))

def mutation(old_population, population):
    mutant = population + 3 * np.random.normal(0, 1) * (old_population - population)
    return mutant

def crossover(mutant, mixrate, popsize, dimensions, population):
    map = np.ones((popsize, dimensions))

    a, b = np.random.uniform(0,1,2)
    if a < b:
        # strategy 1
        for i in range(popsize):
            mutation_indices = np.random.choice(dimensions, int(np.ceil(mixrate * dimensions * np.random.uniform(0,1))), replace=False)
            map[i, mutation_indices] = 0
    else:
        # strategy 2
        for i in range(popsize):
            map[i, np.random.randint(0, dimensions)] = 0

    T = mutant
    for i in range(popsize):
        for j in range(dimensions):
            if map[i, j] == 1:
                T[i, j] = population[i, j]
    return T

def boundary_control(T, bounds):
    lower_bound = bounds[0]
    higher_bound = bounds[1]

    mask_upper = T > higher_bound
    mask_lower = T < lower_bound

    T[mask_upper | mask_lower] = np.random.uniform(lower_bound, higher_bound)

    return T

def bsa(obj_function, popsize, dimensions, max_eval, bounds, optimal_value, mixrate):
    global_min = np.PINF
    global_best = np.zeros(dimensions)

    population = init_population(popsize, dimensions, bounds)
    old_population = init_population(popsize, dimensions, bounds)

    fitness_values = np.apply_along_axis(obj_function, 1, population)
    obj_eval_count = popsize

    while True:
        # selection 1
        a,b = np.random.uniform(0,1,2)
        if a < b:
            old_population = population.copy()

        np.random.shuffle(old_population) # permuting individuals

        # mutation
        mutant = mutation(old_population, population)

        # crossover
        T = crossover(mutant, mixrate, popsize, dimensions, population)

        # boundary control
        T = boundary_control(T, bounds)

        # selection 2
        fitness_values_T = np.apply_along_axis(obj_function, 1, T)
        obj_eval_count += popsize

        for j in range(popsize):
            if fitness_values_T[j] < fitness_values[j]:
                fitness_values[j] = fitness_values_T[j]
                population[j] = T[j]

        fitness_best = np.min(fitness_values)
        if fitness_best < global_min:
            global_min = fitness_best
            global_best = population[np.argmin(fitness_values)]

        if fitness_best <= optimal_value:
            break
        if obj_eval_count >= max_eval:
            break

    return global_min, global_best

for function, bounds in zip(
    [ackley, rastrigin, schwefel, rosenbrock],
    [bounds_ackley, bounds_rastrigin, bounds_schwefel, bounds_rosenbrock]
):
    global_minima = []
    runtimes = []  # Store runtime for each run
    print(f"Running optimization for function: {function.__name__}")

    # Perform multiple runs and track runtime
    for i in range(num_runs):
        start_time = time.time()  # Start timing
        global_min, global_best = bsa(function, pop_size, dimensions, max_eval, bounds, optimal_value, mixrate)
        end_time = time.time()  # End timing

        run_time = end_time - start_time  # Calculate runtime
        runtimes.append(run_time)
        global_minima.append(global_min)

        print(f"Run {i + 1}: Global Minimum = {global_min}, Runtime = {run_time:.4f} seconds")

    # Calculate statistics
    mean_minima = np.mean(global_minima)
    std_minima = np.std(global_minima)
    total_runtime = np.sum(runtimes)
    mean_runtime = np.mean(runtimes)

    # Display results
    print(f"\nFunction: {function.__name__}")
    print(f"Mean of global minima across {num_runs} runs: {mean_minima}")
    print(f"Standard deviation of global minima across {num_runs} runs: {std_minima}")
    print(f"Total runtime across {num_runs} runs: {total_runtime:.4f} seconds")
    print(f"Average runtime per run: {mean_runtime:.4f} seconds\n")

